// Code generated by encgen {{ .Version }}. DO NOT EDIT.

package {{ .Package }}

import (
  "io"

  "github.com/dsnidr/encgen-go"
)

// {{ .Name }}Encoder is the root encoder for {{ .Name }}.
// The user calls .Start() first to begin writing the JSON object.
type {{ .Name }}Encoder struct {
  enc *encgen.Encoder
}

// New{{ .Name }}Encoder creates a new streamable encoder for {{ .Name }}.
func New{{ .Name }}Encoder(w io.Writer) *{{ .Name }}Encoder {
  return &{{ .Name }}Encoder{
    enc: encgen.NewEncoder(w),
  }
}

// Start begins writing the JSON object and returns the encoder for the first field.
//
// Example usage:
//   enc := New{{ .Name }}Encoder(w).Start().<FirstField>(...).<NextField>(...)...
{{- if gt (len .Fields) 0 }}
func (e *{{ .Name }}Encoder) Start() *{{ .Name }}{{ (index .Fields 0).Name }}Encoder {
  e.enc.OpenObject()
  return &{{ .Name }}{{ (index .Fields 0).Name }}Encoder{enc: e.enc}
}
{{- else }}
func (e *{{ .Name }}Encoder) Start() *{{ .Name }}Encoder {
  e.enc.OpenObject()
  return e
}
{{- end }}

{{- $structName := .Name }}
{{- range $index, $field := .Fields }}
{{- $fieldType := $field.TypeInfo }}

{{- if $field.Batchable }}

type {{ $structName }}{{ $field.Name }}EncoderStarter struct {
  enc *encgen.Encoder
}

func (e *{{ $structName }}{{ $field.Name }}EncoderStarter) Start{{ $field.Name }}() *{{ $structName }}{{ $field.Name }}Encoder {
  e.enc.String("\"{{ $field.JSONKey }}\":")
  e.enc.OpenArray()
  return &{{ $structName }}{{ $field.Name }}Encoder{enc: e.enc, firstBatch: true}
}
{{- end }}

// {{ $structName }}{{ $field.Name }}Encoder enforces writing of {{ $field.Name }} next.
type {{ $structName }}{{ $field.Name }}Encoder struct {
  enc *encgen.Encoder
  firstBatch bool
}

{{- if not $field.Batchable }}
func (e *{{ $structName }}{{ $field.Name }}Encoder) {{ $field.Name }}(val {{ $fieldType.TypeString }}) *{{ nextFieldType $structName $.Fields $index }} {
  e.enc.Field("{{ $field.JSONKey }}", val)

  {{- if not (isLastField $.Fields $index )}}
  e.enc.Comma()
  {{- end }}

  return &{{ nextFieldTypeName $structName $.Fields $index }}{enc: e.enc}
}
{{- else }}

// Add{{ $field.Name }} appends items to the batchable field "{{ $field.JSONKey }}".
// Returns the same encoder, allowing chaining .Add{{ $field.Name }}(...).Add{{ $field.Name }}(...)
func (e *{{ $structName }}{{ $field.Name }}Encoder) Add{{ $field.Name }}(items ...{{ $fieldType.ElemType }}) *{{ $structName }}{{ $field.Name }}Encoder {
  if len(items) == 0 {
    return e
  }

  if !e.firstBatch {
    e.enc.Comma()
  }
  e.firstBatch = false 

  {{- $lastIndex := sub (len $field.SubFields) 1 }}

  for idx, item := range items {
    {{- if $fieldType.IsScalar }}
    e.enc.Marshal(item)
    {{- else }}
    e.enc.OpenObject()
    {{- range $i, $sub := $field.SubFields }}
    e.enc.Field("{{ $sub.JSONKey }}", item.{{ $sub.Name }})
    {{ if lt $i $lastIndex }}e.enc.Comma(){{ end }}
    {{- end }}
    e.enc.CloseObject()
    {{- end }}

    if idx < len(items)-1 {
      e.enc.Comma()
    }
  }

  return e
}

// Finish{{ $field.Name }} finishes the batchable field and returns the next encoder in the chain.
func (e *{{ $structName }}{{ $field.Name }}Encoder) Finish{{ $field.Name }}() *{{ nextFieldTypeName $structName $.Fields $index }} {
  e.enc.CloseArray()

  {{- if not (isLastField $.Fields $index) }}
  e.enc.Comma()
  {{- end}}

  return &{{ nextFieldTypeName $structName $.Fields $index }}{enc: e.enc}
}
{{- end }}
{{- end }}

{{- if gt (len .Fields) 0 }}
{{- $lastIndex := sub (len .Fields) 1 }}

type {{ $structName }}FinishEncoder struct {
  enc *encgen.Encoder
}

// Finish finalizes the JSON object and returns any error encountered.
func (e *{{ $structName }}FinishEncoder) Finish() error {
  e.enc.CloseObject()
  return e.enc.Error()
}
{{- end }}
